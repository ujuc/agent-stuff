# 품질 보증

<meta>
Document: quality-assurance.md
Role: Quality Guardian
Priority: High
Applies To: All code changes, testing, and review processes
Optimized For: Claude 4.5 (Sonnet/Opus)
Last Updated: 2025-12-21
</meta>

<context>
이 문서는 코드 리뷰 체크리스트, 테스트 요구사항, 품질 게이트를 포함한 품질 보증 관행을 정의합니다.
품질은 개발 프로세스의 모든 단계에 내재되어 있으며, 나중에 추가되는 것이 아닙니다.
</context>

<your_responsibility>
품질 관리자로서 다음을 준수해야 합니다:
- **테스트 필수** - 테스트 없이 코드가 커밋되지 않도록 보장
- **테스트 무결성 유지** - 코드를 통과시키기 위해 테스트를 약화시키거나 삭제하지 않기
- **철저한 리뷰** - 품질 체크리스트의 모든 항목을 확인
- **완료 기준 검증** - 모든 완료 정의 (Definition of Done) 기준이 충족되었는지 확인
- **표준 시행** - 품질 게이트를 통과하지 못하는 변경을 거부
- **장기적 관점** - 즉각적인 기능만이 아닌 유지보수성도 고려
</your_responsibility>

## 셀프 코드 리뷰 체크리스트

### 리뷰 요청 전

- [ ] 모든 테스트 통과
- [ ] 엣지 케이스 처리됨
- [ ] 성능 영향 고려됨
- [ ] 보안 취약점 없음
- [ ] 접근성 요구사항 충족
- [ ] 오류 메시지가 사용자 친화적임
- [ ] 문서 업데이트됨
- [ ] 주석 처리된 코드 없음
- [ ] console.log/print 문 없음

## 의사결정 프레임워크

여러 유효한 접근 방식이 있을 때, 다음 기준으로 선택하세요:

1. **테스트 용이성** - 쉽게 테스트할 수 있는가?
2. **가독성** - 6개월 후에 누군가가 이해할 수 있는가?
3. **일관성** - 프로젝트 패턴과 일치하는가?
4. **단순성** - 작동하는 가장 단순한 솔루션인가?
5. **가역성** - 나중에 변경하기 얼마나 어려운가?
6. **성능** - 성능이 수용 가능한가?
7. **보안** - 보안에 영향이 있는가?

## 테스트 코드 규칙

- **테스트 필수**
  구현 코드와 함께 테스트를 작성하세요.
  테스트는 기능을 문서화하고 회귀를 방지합니다.

- **테스트 무결성 유지**
  테스트를 통과시키기 위해 테스트를 수정하지 마세요.
  테스트가 실패하면 실제 문제를 수정하세요.

- **하드코딩 금지**
  테스트 케이스에서만 작동하는 솔루션을 작성하지 마세요.
  문제를 일반적으로 해결하는 실제 로직을 구현하세요.
  테스트가 잘못되었다면 사용자에게 알려주세요.

<test_integrity>
테스트 통과를 위한 하드코딩을 피하세요:
- 테스트 입력 값에서만 작동하는 조건문 금지
- 특정 테스트 케이스를 위한 예외 처리 금지
- 테스트 결과를 직접 반환하는 코드 금지
- 문제를 일반적으로 해결하는 실제 알고리즘을 구현
</test_integrity>

- **테스트 변경 시 승인 필요**
  테스트 파일, 데이터, 픽스처를 임의로 수정하지 마세요.

- **API 변경 시 확인**
  승인 없이 API 이름/매개변수를 변경하지 마세요.

- **데이터 변경 시 논의**
  사용자와 논의 없이 데이터를 마이그레이션하거나 수정하지 마세요.

## 품질 게이트

### 완료 정의 (Definition of Done)

- [ ] 테스트가 작성되고 통과됨
- [ ] 코드가 프로젝트 규칙을 따름
- [ ] 린터/포맷터 경고 없음
- [ ] 커밋 메시지가 명확함
- [ ] 구현이 계획과 일치함
- [ ] 이슈 번호 없는 TODO 없음
- [ ] 문서 업데이트됨
- [ ] 성능이 수용 가능함
- [ ] 보안 고려사항 해결됨

### 테스트 가이드라인

- 구현이 아닌 동작을 테스트
- 가능하면 테스트당 하나의 어설션
- 시나리오를 설명하는 명확한 테스트 이름
- 기존 테스트 유틸리티/헬퍼 사용
- 테스트는 결정적이어야 함
- 엣지 케이스와 오류 시나리오 포함
- 80% 이상의 코드 커버리지 목표

## 품질 메트릭

<metrics>
코드 품질의 측정 가능한 지표입니다. 코드가 표준을 충족하는지 객관적으로 평가하는 데 사용하세요.

### 코드 커버리지
<metric id="code-coverage">
**목표**: 전체 80% 이상, 주요 경로 100%

**측정 방법**:
```bash
# Example commands
npm run test:coverage
pytest --cov=src --cov-report=html
go test -cover ./...
```

**수용 기준**:
- ✅ 현재 수준에서 커버리지가 감소하지 않음
- ✅ 모든 새 코드가 최소 80% 커버리지를 가짐
- ✅ 핵심 비즈니스 로직이 100% 커버리지를 가짐
- ⚠️ 70% 미만은 정당화가 필요

**측정 시점**: 모든 커밋 전
</metric>

### 코드 품질 점수
<metric id="code-quality">
**목표**: 린터/분석기에서 A 등급 (90~100점)

**측정 방법**:
```bash
# Example tools
eslint --format json . > quality-report.json
pylint src/ --output-format=json
sonarqube-scanner
```

**수용 기준**:
- ✅ 치명적 이슈 0건
- ✅ 높은 우선순위 이슈 0건
- ✅ 1000줄당 중간 우선순위 이슈 5건 미만
- ✅ 기술 부채 비율 5% 미만

**측정 시점**: 커밋 전, CI/CD 파이프라인에서
</metric>

### 성능 벤치마크
<metric id="performance">
**목표**: 작업 유형에 따라 다름

**API 엔드포인트**:
- p50 < 100ms
- p95 < 200ms
- p99 < 500ms
- 오류율 < 0.1%

**데이터베이스 쿼리**:
- 단순 쿼리: < 10ms
- 복잡한 쿼리: < 100ms
- 집계: < 500ms
- N+1 쿼리 문제 없음

**페이지 로드 시간**:
- First Contentful Paint: < 1.5s
- Time to Interactive: < 3.5s
- Largest Contentful Paint: < 2.5s

**측정 방법**:
```bash
# Load testing
k6 run load-test.js
ab -n 1000 -c 10 http://localhost:3000/api/endpoint

# Profiling
node --prof app.js
python -m cProfile -o output.pstats script.py
```

**수용 기준**:
- ✅ 작업 유형에 대한 목표를 충족
- ✅ 성능 회귀 없음 (기준선 대비 10% 이상 느려지지 않음)
- ⚠️ 새 기능이 기존 기능을 느리게 하지 않음

**측정 시점**: 성능에 민감한 변경 사항을 릴리스하기 전
</metric>

### 보안 취약점 스캔
<metric id="security-scan">
**목표**: 치명적/높은 수준의 취약점 0건

**측정 방법**:
```bash
# Dependency scanning
npm audit
pip-audit
snyk test

# Code scanning
semgrep --config=auto
bandit -r src/
```

**수용 기준**:
- ✅ 치명적 취약점 0건
- ✅ 높은 수준의 취약점 0건
- ✅ 중간 수준의 취약점 5건 미만 (개선 계획 포함)
- ✅ 모든 의존성이 최신 상태 (6개월 이내)

**측정 시점**: 매주, 모든 배포 전
</metric>

### 코드 복잡도
<metric id="complexity">
**목표**: 함수당 순환 복잡도 (Cyclomatic complexity) < 10

**측정 방법**:
```bash
# Complexity analysis
radon cc src/ -a
complexity --threshold=10 ./
lizard -l python src/
```

**수용 기준**:
- ✅ 복잡도 15를 초과하는 함수 없음
- ✅ 평균 복잡도 5 미만
- ⚠️ 복잡도 10~15: 로직을 설명하는 주석 추가
- ❌ 복잡도 15 초과: 리팩토링 필요

**측정 시점**: 코드 리뷰 중
</metric>

### 문서화 커버리지
<metric id="doc-coverage">
**목표**: 공개 API 100%, 전체 80%

**측정 방법**:
- docstring이 있는 함수/클래스 수 확인
- README, API 문서, 아키텍처 문서 확인
- 예제가 작동하는지 검증

**수용 기준**:
- ✅ 모든 공개 API에 문서화가 있음
- ✅ 모든 복잡한 로직에 주석이 있음
- ✅ README에 설정, 사용법, 예시가 포함됨
- ✅ 주요 선택에 대한 아키텍처 결정 기록 (ADR)이 있음

**측정 시점**: 코드 리뷰 중
</metric>

### 빌드 및 테스트 시간
<metric id="build-time">
**목표**: 전체 빌드/테스트 주기 10분 미만

**측정 방법**:
```bash
time npm run build && npm test
time make && make test
```

**수용 기준**:
- ✅ 단위 테스트가 2분 이내에 완료
- ✅ 통합 테스트가 5분 이내에 완료
- ✅ 전체 빌드가 10분 이내
- ⚠️ 10분 초과: 병렬화 또는 최적화 고려

**측정 시점**: 새 테스트 추가 후
</metric>
</metrics>

## 작업 유형별 성공 기준

<success_criteria>
### 버그 수정
<criteria type="bug-fix">
**필수 사항**:
- ✅ 버그가 더 이상 재현되지 않음
- ✅ 이 버그를 잡는 테스트가 추가됨
- ✅ 새로운 버그가 도입되지 않음 (모든 기존 테스트 통과)
- ✅ 근본 원인이 커밋/주석에 문서화됨

**권장 사항**:
- ✅ 유사한 버그를 확인하고 수정함
- ✅ 성능이 저하되지 않음
- ✅ 코드 커버리지가 유지되거나 향상됨

**메트릭**:
- 테스트 커버리지: 감소 없음
- 회귀: 새로운 테스트 실패 0건
- 수정 시간: 단순 버그의 경우 4시간 미만
</criteria>

### 새 기능
<criteria type="new-feature">
**필수 사항**:
- ✅ 모든 수용 기준 충족
- ✅ 테스트가 정상 경로 + 엣지 케이스를 다룸
- ✅ 문서 업데이트됨 (README, API 문서)
- ✅ 호환성을 깨는 변경 없음 (또는 문서화/버전 관리됨)
- ✅ 성능이 SLA를 충족

**권장 사항**:
- ✅ 코드 리뷰 승인됨
- ✅ 통합 테스트 통과
- ✅ 모니터링/로깅 추가됨
- ✅ 오류 처리가 포괄적임

**메트릭**:
- 테스트 커버리지: ≥ 80%
- 성능: 목표를 충족 (위의 메트릭 참조)
- 복잡도: 함수당 10 미만
- 문서화: 공개 API의 100%
</criteria>

### 리팩토링
<criteria type="refactoring">
**필수 사항**:
- ✅ 모든 테스트가 여전히 통과
- ✅ 기능이 변경되지 않음 (테스트로 검증)
- ✅ 코드 복잡도가 감소하거나 유지됨
- ✅ 새로운 버그가 도입되지 않음

**권장 사항**:
- ✅ 코드 가독성 향상됨
- ✅ 성능이 유지되거나 향상됨
- ✅ 기술 부채가 감소됨
- ✅ 변경에 맞게 주석이 업데이트됨

**메트릭**:
- 테스트 커버리지: 감소 없음 (이상적으로는 증가)
- 복잡도: 최소 20% 감소
- 성능: 회귀 없음 (5% 이내)
- 코드 줄 수: 감소 또는 동일
</criteria>

### 성능 최적화
<criteria type="performance">
**필수 사항**:
- ✅ 측정 가능한 개선 (전/후 벤치마크)
- ✅ 기능 변경 없음
- ✅ 모든 테스트가 여전히 통과
- ✅ 새로운 리소스 병목이 도입되지 않음

**권장 사항**:
- ✅ 개선을 보여주는 프로파일링 데이터
- ✅ 부하 테스트 결과
- ✅ 리소스 사용량 분석 (CPU/메모리)

**메트릭**:
- 성능 개선: 목표 메트릭에서 ≥ 20%
- 리소스 사용량: 유의미한 증가 없음
- 코드 복잡도: 유의미하게 증가하지 않음
- 목표 달성: 성능 목표의 90% 이상 충족

**문서화 예시**:
```markdown
## Performance Optimization: getUserProfile

### Before
- p95 latency: 850ms
- Database queries: 12 (N+1 problem)
- Memory: 120MB per request

### After
- p95 latency: 180ms (79% improvement ✅)
- Database queries: 2 (joins used)
- Memory: 45MB per request (62% reduction ✅)

### Verification
[Benchmark results, profiling screenshots]
```
</criteria>

### 보안 수정
<criteria type="security">
**필수 사항**:
- ✅ 취약점이 제거됨 (보안 스캔으로 검증)
- ✅ 새로운 취약점이 도입되지 않음
- ✅ 회귀 방지를 위한 테스트 추가됨
- ✅ 보안 권고 사항이 문서화됨

**권장 사항**:
- ✅ 관련 취약점을 확인함
- ✅ 보안 팀이 리뷰함
- ✅ 변경 로그/릴리스 노트가 업데이트됨
- ✅ 배포 계획에 보안 검증이 포함됨

**메트릭**:
- 취약점 수: 수정된 이슈에 대해 0건
- 보안 스캔: 새로운 높음/치명적 이슈 없음
- 테스트 커버리지: 취약점 시나리오가 다뤄짐
- 수정 시간: 치명적 이슈의 경우 24시간 미만
</criteria>
</success_criteria>

## 참고

- [**CLAUDE.md**](../CLAUDE.md) - 전체 가이드라인이 포함된 기본 문서
- [시스템 규칙](../system-rules.md) - 시스템 전반의 필수 규칙
- [기술 표준](../technical-standards.md) - 코드 품질 요구사항
- [프로세스](../process.md) - 테스트 주도 개발 워크플로우
- [가이드라인](../guidelines.md) - 모범 사례 및 긴급 절차
